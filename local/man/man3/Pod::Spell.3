.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Spell 3"
.TH Pod::Spell 3 "2013-11-02" "perl v5.16.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Spell \- a formatter for spellchecking Pod
.SH "VERSION"
.IX Header "VERSION"
version 1.13
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        use Pod::Spell;
\&        Pod::Spell\->new\->parse_from_file( \*(AqFile.pm\*(Aq );
\&
\&        Pod::Spell\->new\->parse_from_filehandle( $infile, $outfile );
.Ve
.PP
Also look at podspell
.PP
.Vb 1
\&        % perl \-MPod::Spell \-e "Pod::Spell\->new\->parse_from_file(shift)" Thing.pm |spell |fmt
.Ve
.PP
\&...or instead of piping to spell or \f(CW\*(C`ispell\*(C'\fR, use \f(CW\*(C`>temp.txt\*(C'\fR, and open
\&\fItemp.txt\fR in your word processor for spell-checking.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod::Spell is a Pod formatter whose output is good for
spellchecking.  Pod::Spell rather like Pod::Text, except that
it doesn't put much effort into actual formatting, and it suppresses things
that look like Perl symbols or Perl jargon (so that your spellchecking
program won't complain about mystery words like "\f(CW$thing\fR\*(L"
or \*(R"\f(CW\*(C`Foo::Bar\*(C'\fR\*(L" or \*(R"hashref").
.PP
This class provides no new public methods.  All methods of interest are
inherited from Pod::Parser (which see).  The especially
interesting ones are \f(CW\*(C`parse_from_filehandle\*(C'\fR (which without arguments
takes from \s-1STDIN\s0 and sends to \s-1STDOUT\s0) and \f(CW\*(C`parse_from_file\*(C'\fR.  But you
can probably just make do with the examples in the synopsis though.
.PP
This class works by filtering out words that look like Perl or any
form of computerese (like "\f(CW$thing\fR\*(L" or \*(R"\f(CW\*(C`N>7\*(C'\fR\*(L" or
\&\*(R"\f(CW\*(C`@{$foo}{\*(Aqbar\*(Aq,\*(Aqbaz\*(Aq}\*(C'\fR", anything in C<...> or F<...>
codes, anything in verbatim paragraphs (code blocks), and anything
in the stopword list.  The default stopword list for a document starts
out from the stopword list defined by Pod::Wordlist,
and can be supplemented (on a per-document basis) by having
\&\f(CW"=for stopwords"\fR / \f(CW"=for :stopwords"\fR region(s) in a document.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.SS "command"
.IX Subsection "command"
.SS "interior_sequence"
.IX Subsection "interior_sequence"
.SS "textblock"
.IX Subsection "textblock"
.SS "verbatim"
.IX Subsection "verbatim"
.SS "stopwords"
.IX Subsection "stopwords"
.Vb 1
\&        $self\->stopwords\->isa(\*(AqPod::WordList\*(Aq); # true
.Ve
.SH "ENCODINGS"
.IX Header "ENCODINGS"
Pod::Parser, which Pod::Spell extends, is extremely naive about
character encodings.  The \f(CW\*(C`parse_from_file\*(C'\fR method does not apply
any PerlIO encoding layer.  If your Pod file is encoded in \s-1UTF\-8\s0,
your data will be read incorrectly.
.PP
You should instead use \f(CW\*(C`parse_from_filehandle\*(C'\fR and manage the input
and output layers yourself.
.PP
.Vb 3
\&        binmode($_, ":utf8") for ($infile, $outfile);
\&        $my ps = Pod::Spell\->new;
\&        $ps\->parse_from_filehandle( $infile, $outfile );
.Ve
.PP
If your output destination cannot handle \s-1UTF\-8\s0, you should set your
output handle to Latin\-1 and tell Pod::Spell to strip out words
with wide characters.
.PP
.Vb 4
\&        binmode($infile, ":utf8");
\&        binmode($outfile, ":encoding(latin1)");
\&        $my ps = Pod::Spell\->new( no_wide_chars => 1 );
\&        $ps\->parse_from_filehandle( $infile, $outfile );
.Ve
.SH "ADDING STOPWORDS"
.IX Header "ADDING STOPWORDS"
You can add stopwords on a per-document basis with
\&\f(CW"=for stopwords"\fR / \f(CW"=for :stopwords"\fR regions, like so:
.PP
.Vb 2
\&  =for stopwords  plok Pringe zorch   snik !qux
\&  foo bar baz quux quuux
.Ve
.PP
This adds every word in that paragraph after \*(L"stopwords\*(R" to the
stopword list, effective for the rest of the document.  In such a
list, words are whitespace-separated.  (The amount of whitespace
doesn't matter, as long as there's no blank lines in the middle
of the paragraph.)  Plural forms are added automatically using
Lingua::EN::Inflect. Words beginning with \*(L"!\*(R" are
\&\fIdeleted\fR from the stopword list \*(-- so \*(L"!qux\*(R" deletes \*(L"qux\*(R" from the
stopword list, if it was in there in the first place.  Note that if
a stopword is all-lowercase, then it means that it's okay in \fIany\fR
case; but if the word has any capital letters, then it means that
it's okay \fIonly\fR with \fIthat\fR case.  So a Wordlist entry of \*(L"perl\*(R"
would permit \*(L"perl\*(R", \*(L"Perl\*(R", and (less interestingly) \*(L"\s-1PERL\s0\*(R", \*(L"pERL\*(R",
\&\*(L"PerL\*(R", et cetera.  However, a Wordlist entry of \*(L"Perl\*(R" catches
only \*(L"Perl\*(R", not \*(L"perl\*(R".  So if you wanted to make sure you said
only \*(L"Perl\*(R", never \*(L"perl\*(R", you could add this to the top of your
document:
.PP
.Vb 1
\&  =for stopwords !perl Perl
.Ve
.PP
Then all instances of the word \*(L"Perl\*(R" would be weeded out of the
Pod::Spell\-formatted version of your document, but any instances of
the word \*(L"perl\*(R" would be left in (unless they were in a C<...> or
F<...> style).
.PP
You can have several \*(L"=for stopwords\*(R" regions in your document.  You
can even express them like so:
.PP
.Vb 1
\&  =begin stopwords
\&
\&  plok Pringe zorch
\&
\&  snik !qux
\&
\&  foo bar
\&  baz quux quuux
\&
\&  =end stopwords
.Ve
.PP
If you want to use E<...> sequences in a \*(L"stopwords\*(R" region, you
have to use \*(L":stopwords\*(R", as here:
.PP
.Vb 2
\&  =for :stopwords
\&  virtE<ugrave>
.Ve
.PP
\&...meaning that you're adding a stopword of \*(L"virtu\*`\*(R".  If
you left the \*(L":\*(R" out, that would mean you were adding a stopword of
\&\*(L"virtE<ugrave>\*(R" (with a literal E, a literal <, etc), which
will have no effect, since  any occurrences of virtE<ugrave>
don't look like a normal human-language word anyway, and so would
be screened out before the stopword list is consulted anyway.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
.ie n .SS "finding stopwords defined with ""=for"""
.el .SS "finding stopwords defined with \f(CW=for\fP"
.IX Subsection "finding stopwords defined with =for"
Pod::Spell makes a single pass over the \s-1POD\s0.  Stopwords
must be added \fBbefore\fR they show up in the \s-1POD\s0.
.SS "finding the wordlist"
.IX Subsection "finding the wordlist"
Pod::Spell uses File::ShareDir::ProjectDistDir if you're getting errors
about the wordlist being missing, chances are it's a problem with its
heuristics. Set \f(CW\*(C`PATH_ISDEV_DEBUG=1\*(C'\fR or \f(CW\*(C`PATH_FINDDEV_DEBUG=1\*(C'\fR, or both in
your environment for debugging, and then file a bug with
File::ShareDir::ProjectDistDir if necessary.
.SH "HINT"
.IX Header "HINT"
If you feed output of Pod::Spell into your word processor and run a
spell-check, make sure you're \fInot\fR also running a grammar-check \*(-- because
Pod::Spell drops words that it thinks are Perl symbols, jargon, or
stopwords, this means you'll have ungrammatical sentences, what with
words being missing and all.  And you don't need a grammar checker
to tell you that.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Pod::Wordlist
.PP
Pod::Parser
.PP
podchecker also known as Pod::Checker
.PP
perlpod, perlpodspec
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests on the bugtracker website
https://github.com/xenoterracide/pod\-spell/issues
.PP
When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
David Golden <dagolden@cpan.org>
.IP "\(bu" 4
Olivier Mengue\*' <dolmen@cpan.org>
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Sean M. Burke <sburke@cpan.org>
.IP "\(bu" 4
Caleb Cushing <xenoterracide@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by Caleb Cushing.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
